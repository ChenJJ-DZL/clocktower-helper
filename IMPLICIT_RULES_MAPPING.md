# 钟楼谜团隐性规则映射文档

本文档记录了官方规则中的"隐性规则"如何映射到代码逻辑和UI实现上。

## 1. 同时触发 ⚠️

**规则说明**：如果在同一时间多个能力同时满足触发条件，则由说书人来决定这些能力的结算顺序。但说书人应该尽可能按照更有趣而不是更混乱的方式进行结算。

**示例**：哲学家获得了舞蛇人的能力，且同时舞蛇人在场但醉酒。这两名玩家都会在轮到舞蛇人的夜晚顺序时被唤醒。通常来说，说书人应该优先唤醒哲学家让他行动，然后再唤醒舞蛇人。

**实现位置**：
- `src/utils/nightLogic.ts` - `generateNightTimeline` 函数
- `src/hooks/useNightLogic.ts` - `startNight` 函数

**当前实现**：
- ✅ 夜晚顺序表按照角色ID和夜晚顺序排序
- ⚠️ 未实现说书人手动选择同时触发能力的顺序

**待实现**：
- 检测同时触发的能力（相同夜晚顺序的角色）
- 提供UI让说书人选择结算顺序
- 或者按照合理的默认顺序处理（如示例中的哲学家优先）

## 2. 不能最大 ✅

**规则说明**：两个能力（或规则）之间互相冲突时，如果一个能力允许做某事，而另一个能力禁止做某事，则始终以"不能"的能力生效。

**示例**：
- 处决并导致场上所有恶魔死亡会让善良阵营获胜，而镜像双子的能力则会让善良阵营无法获胜。此时镜像双子的能力会生效。
- 弄臣等能力会造成免死效果，而刺客的能力会让"保护某人不会死亡"的能力无法产生效果。

**实现位置**：
- `src/hooks/useGameController.ts` - `checkGameOver` 函数（镜像双子检查）
- `src/hooks/useGameController.ts` - `executePlayer` 函数（保护检查）
- `src/hooks/useGameController.ts` - `hasExecutionProof` 函数

**当前实现**：
- ✅ 镜像双子优先级检查：在 `checkGameOver` 中优先检查镜像双子，如果两个双子都存活，即使恶魔死亡，善良阵营也无法获胜
- ✅ 保护检查：`hasExecutionProof` 检查保护状态，但需要确认刺客等角色的能力能正确覆盖保护

**代码位置**：
```typescript
// 镜像双子检查（第1172-1182行）
if (executionTargetId !== null && executionTargetId !== undefined && evilTwinPair) {
  const executedPlayer = updatedSeats.find(s => s.id === executionTargetId);
  if (executedPlayer && executedPlayer.id === evilTwinPair.goodId) {
    setWinResult('evil');
    // ... 邪恶获胜
    return true;
  }
}

// 镜像双子阻止善良获胜（第1225-1235行）
if (evilTwinPair) {
  const evilTwin = updatedSeats.find(s => s.id === evilTwinPair.evilId);
  const goodTwin = updatedSeats.find(s => s.id === evilTwinPair.goodId);
  const bothAlive = evilTwin && !evilTwin.isDead && goodTwin && !goodTwin.isDead;
  if (bothAlive && deadDemon && !aliveDemon) {
    // 恶魔死亡但双子都存活善良无法获胜游戏继续
    return false;
  }
}
```

**待完善**：
- ✅ 已添加刺客等角色的能力覆盖保护效果的逻辑（在 `hasExecutionProof` 函数中添加了 `attackerRoleId` 参数）
- ⚠️ 需要在调用 `hasExecutionProof` 时传入攻击者角色ID（当前调用处未传入）
- 添加更多禁止性规则优先的检查

## 3. 自我/循环的醉酒/中毒/失去能力 ⚠️

**规则说明**：让自己中毒的能力成功生效时，自身会只保留"让自己中毒"这一条能力的"中毒效果"和"中毒结束条件"，其余的所有能力会全部失去。多个角色之间循环中毒同理，醉酒同理。

**示例**：
- 普卡攻击自身，会让自己中毒，且因为中毒没有结束条件，普卡会因此永久中毒。
- 水手让普卡醉酒，旅店老板让水手醉酒（普卡因此清醒），普卡让旅店老板中毒（水手因此清醒，同时导致普卡醉酒），这三名玩家会一同醉酒/中毒。

**实现位置**：
- `src/hooks/useGameController.ts` - 中毒/醉酒处理逻辑
- `src/utils/gameRules.ts` - `computeIsPoisoned` 函数

**当前实现**：
- ✅ 中毒/醉酒状态管理：通过 `isPoisoned` 和 `isDrunk` 状态
- ✅ 能力失去逻辑：中毒/醉酒时能力失效
- ⚠️ 未实现自我中毒的特殊处理
- ⚠️ 未实现循环中毒的检测和处理

**待实现**：
- 检测自我中毒/醉酒的情况
- 检测循环中毒/醉酒的情况（需要检测循环依赖）
- 实现自我中毒时只保留该能力本身的逻辑
- 实现循环中毒时的正确处理

## 4. 角色唯一 ✅

**规则说明**：相同的角色同一时间只会在场上存在最多一个。如果一项能力允许玩家改变角色，但无明确说明，则这一规则不会被打破。（无神论者例外）

**示例**：工程师的能力生效后造成的角色变化，不会使变化后的这些玩家具有相同的角色。

**实现位置**：
- `src/hooks/useGameController.ts` - 角色变化处理逻辑
- `src/components/game/setup/GameSetup.tsx` - 角色分配界面

**当前实现**：
- ✅ 角色分配界面：显示已选择的角色，防止重复选择
- ✅ 角色变化：通过 `setSeats` 更新角色，但需要确认不会产生重复角色

**代码位置**：
```typescript
// GameSetup.tsx - 防止重复选择角色
const isTaken = seats.some((s) => s.role?.id === r.id);
```

**待完善**：
- 在角色变化时添加检查，确保不会产生重复角色（除非是军团等特殊角色）
- 添加UI提示当尝试创建重复角色时

## 5. 死亡顺序 ✅

**规则说明**：不会存在同一时间多于一名玩家死亡的情况。所有的死亡效果都是依照某个顺序让玩家依次死亡的。

**示例**：恶魔造成的死亡通过攻击顺序决定。流莺会先让她的目标死亡，然后再是自己死亡。

**实现位置**：
- `src/hooks/useGameController.ts` - `killPlayer` 函数
- `src/hooks/useGameController.ts` - `checkGameOver` 函数

**当前实现**：
- ✅ 死亡是顺序的：`killPlayer` 函数一次只处理一个玩家的死亡
- ✅ 死亡之间不插入胜负判断：在 `killPlayer` 中，只有在所有死亡处理完成后才调用 `checkGameOver`

**代码位置**：
```typescript
// killPlayer 函数处理单个玩家死亡
const killPlayer = useCallback((targetId: number, options?: KillPlayerOptions) => {
  // ... 处理单个玩家死亡
  // 只有在所有死亡处理完成后才检查游戏结束
  if (!options?.skipGameOverCheck) {
    checkGameOver(updatedSeats, targetId);
  }
}, []);
```

**待完善**：
- 确保流莺等角色的死亡顺序正确（先目标死亡，再自己死亡）
- 确保痢蛭的宿主与痢蛭的先后死亡过程中不插入胜负条件判断

## 6. 夜晚行动过时不候 ⚠️

**规则说明**：在夜晚时，如果已经开始某个角色的能力结算，那么当晚任何新创建出来的这种角色及具有这种角色能力的角色都不会在当晚进行相应的行动。

**示例**：
- 轮到小恶魔行动，小恶魔的自杀使得一名爪牙变成了小恶魔，因为夜晚行动已经结算到小恶魔，因此新的小恶魔不会在当晚行动。
- 痢蛭杀死了理发师后，交换了自己和一名爪牙的角色，新的痢蛭仍然需要进行选择宿主的行动，因为痢蛭非首夜的夜晚行动中只包含"攻击一名玩家"这个部分，而痢蛭的选择宿主是进场能力，会正常被触发。

**实现位置**：
- `src/hooks/useNightLogic.ts` - `startNight` 函数
- `src/utils/nightQueueGenerator.ts` - 夜晚队列生成

**当前实现**：
- ✅ 夜晚队列在夜晚开始时生成：`generateNightTimeline` 在夜晚开始时生成队列
- ⚠️ 未实现检测新创建的角色并阻止其在当晚行动

**待实现**：
- 跟踪夜晚行动的进度（当前处理到哪个角色）
- 检测新创建的角色（角色变化）
- 阻止新角色的夜晚行动（如果该角色的夜晚行动已经开始）

## 7. 角色详解不考虑中毒醉酒及特殊互动 ✅

**规则说明**：角色详解只提供角色的基本操作方式和常见案例。在考虑中毒醉酒互动，或跨官方剧本、混合剧本中的角色互动时，请勿完全死板依照运作方式进行。理解角色能力本身的逻辑，或者运用游戏理念进行问题的分析，比什么都重要。

**实现位置**：
- 所有角色能力处理逻辑

**当前实现**：
- ✅ 能力逻辑基于角色定义：角色能力通过 `roleActionHandlers.ts` 和角色定义文件实现
- ✅ 中毒/醉酒处理：通过 `isActorDisabledByPoisonOrDrunk` 等函数处理
- ✅ 特殊互动：通过角色特定的处理函数实现

**说明**：
- 这个规则更多是设计理念，代码中已经通过模块化的角色处理逻辑实现了这一点
- 每个角色的能力逻辑独立实现，可以处理特殊互动

## 总结

### 已实现 ✅
1. **不能最大**：镜像双子优先级检查已实现
2. **角色唯一**：角色分配界面防止重复选择
3. **死亡顺序**：死亡是顺序处理的
4. **角色详解不考虑中毒醉酒**：通过模块化逻辑实现

### 部分实现 ⚠️
1. **同时触发**：夜晚顺序已排序，但未实现说书人手动选择顺序
2. **自我/循环的醉酒/中毒**：基本的中毒/醉酒处理已实现，但未实现自我/循环的特殊处理
3. **夜晚行动过时不候**：夜晚队列在开始时生成，但未实现检测新创建角色并阻止行动

### 待实现 ❌
1. 同时触发能力的说书人选择UI
2. 自我中毒的特殊处理逻辑
3. 循环中毒的检测和处理
4. 新创建角色的夜晚行动阻止逻辑

